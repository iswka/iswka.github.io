<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[组件之ActivityIndicator、WebView]]></title>
      <url>%2F2017%2F04%2F15%2Fat02%2F</url>
      <content type="text"><![CDATA[ActivityIndicator 组件作用：显示一个loading加载提示的符号。 属性： animating bool 是否要显示指示器。默认为true color string 滚轮的前景颜色（默认为灰色） size enum(‘small’, ‘large’) 指示器的大小。small的高度为20，large的高度为36. 例子import React, { Component } from &apos;react&apos;; import { ActivityIndicator } from &apos;react-native&apos;; export default class activityIndicator extends Component { render() { return ( &lt;ActivityIndicator style={{ marginTop: 100 }} color=&quot;green&quot; size=&quot;large&quot; /&gt; ); } } WebView 组件作用创建一个原生的WebView，可以用于访问一个网页。 用法 webView,网络视图可以在这个内部引入别的网页，使用source进入引入 例子import React, { Component } from &apos;react&apos;; import { WebView } from &apos;react-native&apos;; // 引入京东手机版 export default class WebViewCom extends React.Component { render() { return ( &lt;WebView source={{ url: 'http://m.jd.com' }} /&gt; ); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[练习题]]></title>
      <url>%2F2017%2F04%2F14%2Freact_native%2Fexercise05%2F</url>
      <content type="text"><![CDATA[实现一个Navigator，要求包括跳转到新页面的新页面的回退，并且在页面切换时有数据传输 import React, { Component } from &apos;react&apos;; import { Navigator, Text, TextInput, View, TouchableOpacity, StyleSheet } from &apos;react-native&apos;; export default class Nav extends Component { render() { // 初始化路由 var rootRoute = { component: FirstPage, nextPass: {} }; return ( &lt;Navigator //{/* 设置默认的路由 */} initialRoute={ rootRoute } //{/* 切换页面方式 */} configureScene={ (route) =&gt; Navigator.SceneConfigs.PushFromRight } //{/* 确定要渲染的场景 */} renderScene={ (route, navigator) =&gt; { // 找到要渲染的页面 var Component = route.component; // 返回组件， 把组件的route 和 navigator // 把属性也传递过去 return &lt;Component { ...route.nextPass } route={ route } navigator={ navigator }/&gt; }} /&gt; ); } } class SecondPage extends Component { changePage() { this.props.navigator.pop(); } render() { return ( &lt;View style={[ styles.second, styles.container ]}&gt; &lt;Text&gt;接收到的数据：{ this.props.text }&lt;/Text&gt; &lt;TouchableOpacity style={ styles.btn } onPress={ this.changePage.bind(this) }&gt; &lt;Text style={ styles.txt }&gt;点击返回上一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } class FirstPage extends Component { constructor(props) { super(props); this.state = { text: &apos;&apos; } } saveText(text) { this.setState({ text: text }); } changePage() { var nextRoute = { component: SecondPage, nextPass: { text: this.state.text } }; this.props.navigator.push(nextRoute); } render() { return ( &lt;View style={[ styles.first, styles.container ]}&gt; &lt;TextInput placeholder={ &apos;请输入&apos; } style={ styles.input } onChangeText={ this.saveText.bind(this) }&gt;&lt;/TextInput&gt; &lt;TouchableOpacity style={ styles.btn } onPress={ this.changePage.bind(this) }&gt; &lt;Text style={ styles.txt }&gt;点击进入下一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, }, first: { backgroundColor: &apos;cyan&apos;, }, second: { backgroundColor: &apos;pink&apos;, }, input: { height: 25, borderWidth: 1, }, btn: { width: 150, height: 20, backgroundColor: &apos;yellow&apos;, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, borderRadius: 5, }, txt: { } }); 实现一个TabBar，要求至少包括四项，要求有四项标签 import React, { Component } from &apos;react&apos;; import { TabBarIOS, Text, View, StyleSheet } from &apos;react-native&apos;; // 引入三个图片 import movieIcon from &apos;./../public/images/movie.png&apos;; import homeIcon from &apos;./../public/images/home.png&apos;; import picIcon from &apos;./../public/images/pic.png&apos;; import musicIcon from &apos;./../public/images/music.png&apos;; export default class TabBar2 extends Component { constructor(props) { super(props); // 初始状态 this.state = { isShow: &apos;首页&apos; }; } press(tabName) { this.setState({ isShow: tabName }); } render() { return ( &lt;TabBarIOS&gt; &lt;TabBarIOS.Item title=&quot;首页&quot; icon={ homeIcon } onPress={ this.press.bind(this, &apos;首页&apos;) } selected={ this.state.isShow === &apos;首页&apos; } &gt; &lt;FirstPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;电影&quot; icon={ movieIcon } onPress={ this.press.bind(this, &apos;电影&apos;) } selected={ this.state.isShow === &apos;电影&apos; } &gt; &lt;SecondPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;相册&quot; icon={ picIcon } onPress={ this.press.bind(this, &apos;相册&apos;) } selected={ this.state.isShow === &apos;相册&apos; } &gt; &lt;ThreePage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;音乐&quot; icon={ musicIcon } onPress={ this.press.bind(this, &apos;音乐&apos;) } selected={ this.state.isShow === &apos;音乐&apos; } &gt; &lt;FourPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); } } class FourPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.four ]}&gt; &lt;Text&gt;这是第四个页面&lt;/Text&gt; &lt;/View&gt; ); } } class ThreePage extends Component { render() { return ( &lt;View style={[ styles.container, styles.three ]}&gt; &lt;Text&gt;这是第三个页面&lt;/Text&gt; &lt;/View&gt; ); } } class SecondPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.second ]}&gt; &lt;Text&gt;这是第二个页面&lt;/Text&gt; &lt;/View&gt; ); } } class FirstPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.first ]}&gt; &lt;Text&gt;这是第一个页面&lt;/Text&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, }, first: { backgroundColor: &apos;yellow&apos;, }, second: { backgroundColor: &apos;red&apos;, }, three: { backgroundColor: &apos;blue&apos; }, four: { backgroundColor: &apos;pink&apos; } }); 实现一个电影列表，要求通过网络请求读取数据，通过ListView实现，并且在数据加载时有loading组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown-快速入门]]></title>
      <url>%2F2017%2F04%2F14%2Fmarkdown%2Fbasic%2F</url>
      <content type="text"><![CDATA[前言markdown是一门很容易上手的轻量级语言这里提供一个Dingus,它是一个网页应用程序，可以将MarkDown文档转换成XHTML文档。 段落一般由回车换行即可，MarkDown将该行为标识为一个段落【注意：这样的段落没有缩进】 标题MarkDown支持两种标题语法，Setext和tx形式。Setext用底限形式，利用=（最高阶标题）和-（第二阶标题）；Atx是在行首插入1到6个#，对应HTML标题H1…H6。 区块代码区块代码使用Email形式的’&gt;’角括号 修辞和强调使用星号 (*) 和 (_) 底线标记需要强调的区段 _修辞和强调的区段_ 等价于 &lt;em&gt;修辞和强调的区段&lt;/em&gt; *修辞和强调的区段* 等价于 &lt;em&gt;修辞和强调的区段&lt;/em&gt; __修辞和强调的区段__ 等价于 &lt;strong&gt;修辞和强调的区段&lt;/strong&gt; **修辞和强调的区段** 等价于 &lt;strong&gt;修辞和强调的区段&lt;/strong&gt; 列表无序列表： 使用星号（*）加号（+）减号（-）来作为列表的项目标记 有序列表： 一般是一个数字接着一个英文句点（.）作为项目标记 链接支持两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号把文字转成链接。 行内形式是直接在后面用括号直接接上链接 This is an [example link](http://example.com/). 你也可以选择性的加上title属性 This is an [example link](http://example.com/ &quot;With a title&quot;). 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容。 I get 10 times more traffic from [Google][1] than from [baidu][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://baidu.com/ &quot;Baidu&quot; [3]: http://search.msn.com/ &quot;MSN&quot; 图片图片的语法和链接一样，同样有行内和参考两种形式， 行内形式 ![alt text](/path/icon.png &quot;Title&quot;) 参考形式 ![alt text][id] [id]: /path/icon.png &quot;Title&quot; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp; 、 &lt; 和 &gt; 都会被转换成HTML实体，这项特性让你可以很容易的在代码区段内插入HTML代码 如果要建立一个已经格式化好的代码区块，只要每行缩进4个空格或者一个Tab就可以了。而 &amp; 、&lt; 和 &gt; 也一样会转成HTML实体]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组件之navigator、ListView]]></title>
      <url>%2F2017%2F04%2F14%2Freact_native%2Fat01%2F</url>
      <content type="text"><![CDATA[Navigator使用导航器可以让你在应用的不同场景（页面）进行切换。导航器通过不同路由来分辨不同的场景。利用renderScene方法，导航栏可以指定的路由来渲染场景 可以通过configureScene属性获取指定路由对象的配置信息，从而改变场景的动画或者手势。查看navigator.SceneConfigs来获取默认的动画和更多的场景配置选项。 注意：这个组件本文说明简单，但使用上有一定难度。 在使用该组件时，一般需要以下几步： 属性： configScene (function) 可选的函数，用来配置场景动画和手势。会带有两个参数调用，一个是当前路由，一个是当前的路由栈， 然后它返回一个场景配置对象。 initialRoute (object) 定义启动加载的路由，路由是导航栏用来识别渲染场景的一个对象，initialRoute必须是initialRouteStack 中的一个路由。initialRoute默认是initialRouteStack中最后一项。 initialRouteStack (object) 提供一个路由集合用来初始化。如果没有设置初始路由的话必须设置初始路由。如果没有提供该属性，它将默认被设置 成一个只含有initialRoute的数组。 navigationBar (node) 可选参数，提供一个在场景切换的时候保持的导航条。 navigator (object) 可选参数，提供从父容器获得的导航器对象。 onDidFocus (function) 每当导航条切换完成或者初始化之后，调用此函数，参数为新场景的路由。 onWillFocus (function) 会在导航条切换之前调用，参数为目标路由。 renderScene (function) 必要参数。用来渲染指定参数路由的场景。调用的参数是路由和导航器。 senceStyle (View#style) 将会应用在每个场景容器上的样式。 ListView核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表。最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组，再使用数据源实例化一个ListView组件，并且定义它的回调函数_renderRow。该函数会接受数组中每个数据作为参数。返回一个可渲染的组件。 ListView还支持一些高级特性，这个本人还没有尝试，以后详解哈。 属性： renderRow (function) 从数据源中接收一条数据，以及和它所在的section的ID。返回一个可渲染的组件来为这行数据进行渲染。默认情况下 参数中的数据就是放进数据源的数据本身，不过也可以提供一些转换器。 如果某一行正在被高亮（通过调用highlightRow函数），ListView会得到相应的通知。当一行被高亮时，其两侧的分割线 会被隐藏。行的高亮状态可以通过调用highlistRow(null)来重置。 renderHeader (function) 渲染页头。 renderSeparator (function) 如果提供了此属性，一个可渲染的组件会被渲染在每一行的下面。除了小节标题的前面的最后一行。在其上方的小节ID和行ID，以及 邻近的行是否被高亮会作为参数被传递进来。 例子： /** * 猫眼电影列表页 * 数据 * http://m.maoyan.com/movie/list.json?type=hot&amp;offset=0&amp;limit=1000 */ import React, { Component } from &apos;react&apos;; import { ListView, ActivityIndicator, View, Text, Image, StyleSheet } from &apos;react-native&apos;; // 引入猫眼数据 import movieData from &apos;./../public/json/maoyan.json&apos;; export default class MoveList extends Component { constructor(props) { super(props); var ds = new ListView.DataSource({ rowHasChanged: (oldData, newData) =&gt; oldData !== newData }); this.state = { dataSource: ds }; } _renderHeader() { return ( &lt;View style={ styles.header }&gt; &lt;Text style={ styles.header_txt }&gt;猫眼热门电影&lt;/Text&gt; &lt;/View&gt; ); } _renderRow(movie) { return ( &lt;View style={ styles.row }&gt; &lt;View style={ styles.left }&gt; &lt;Image source={{ uri: movie.img }} style={ styles.img }&gt;&lt;/Image&gt; &lt;/View&gt; &lt;View style={ styles.right }&gt; &lt;Text style={[ styles.nm, styles.txt_right ]}&gt;{ movie.nm }&lt;/Text&gt; &lt;Text style={[ styles.dir, styles.txt_right ]}&gt;导演：{ movie.dir }&lt;/Text&gt; &lt;Text style={[ styles.rt, styles.txt_right ]}&gt;上映时间：{ movie.rt }&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); } _renderSeparator() { return ( &lt;View style={ styles.separator }&gt;&lt;/View&gt; ); } componentDidMount() { // 把已经解析好的数据使用到我们的页面 var ds = new ListView.DataSource({ rowHasChanged: (oldData,newData) =&gt; oldData !== newData }); this.setState({ dataSource: ds.cloneWithRows(movieData.data.movies) }); } render() { return ( &lt;ListView style={ styles.container } dataSource={ this.state.dataSource } renderHeader={ this._renderHeader } renderRow={ this._renderRow } renderSeparator={ this._renderSeparator } &gt; &lt;/ListView&gt; ); } } const styles = StyleSheet.create({ container: { marginTop: 25, marginLeft: 10, marginRight: 10, }, header: { height: 50, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;pink&apos;, borderRadius: 6, }, header_txt: { fontSize: 30, color: &apos;darkgrey&apos; }, row: { height: 160, flexDirection: &apos;row&apos;, marginTop: 10, }, left: { width: 110, }, right: { justifyContent: &apos;center&apos;, }, separator: { height: 2, backgroundColor: &apos;#ccc&apos; }, img: { width: 100, height: 150, }, txt_right: { marginBottom: 10 }, nm: { fontSize: 26, fontWeight: &apos;bold&apos;, }, dir: { fontSize: 16, color: &apos;orange&apos; }, rt: { color: &apos;grey&apos; } }); 提示 有关猫眼数据，可点击链接接收JSON数据：http://m.maoyan.com/movie/list.json?type=hot&amp;offset=0&amp;limit=100【limit=?，这里输入的是你要获取电影信息的条目数，最多只能获取100条】 效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的Angular疑问解答]]></title>
      <url>%2F2017%2F04%2F13%2Fangularjs%2Fexercise01%2F</url>
      <content type="text"><![CDATA[列举你所知道的angular指令（不少于10个） ng-bind ng-model ng-app ng-controller ng-init ng-repeat ng-hide ng-show ng-if ng-keydown 请写出一个双向数据绑定的例子&lt;div ng-app=&quot;myApp&quot; ng-init=&quot;name=&apos;John&apos;&quot;&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;你输入的姓名：{{ name }}&lt;/p&gt; &lt;/div&gt; 请列举写出angular的事件绑定，要求事件触发时会有相应的方法执行&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;button ng-click=&quot;handler()&quot;&gt;&lt;/button&gt; &lt;p ng-show=&quot;isShow&quot;&gt;隐藏/显示&lt;/p&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, function ($scope) { $scope.isShow = true; $scope.handler = function () { $scope.isShow = !$scope.isShow; } }); &lt;/script&gt; &lt;/body&gt; 请举例写出angular自定义指令的方法app.directive(&apos;helloWorld&apos;, function () { return ( template: &apos;&lt;h1&gt;自定义指令&lt;/h1&gt;&apos; ); }); 请举例写出angular发请求的方法（如，发请求到http://localhost:8080/req),并写出返回的数据怎么得到$http({ method: &apos;GET&apos;. url: &apos;http://localhost:8080/req&apos;, }).then(function (res) { // 成功的回调 console.log(res.data); }, function (err) { // 失败的回调 console.log(err); }); ng-show/ng-hide 与 ng-if 的区别？ng-show/ng-hide: 显示或者隐藏HTML元素ng-if: 如果条件为false移除HTML元素，如果条件为true，会添加移除元素，并显示。两者之间最大的区别就是ng-hide是隐藏而ng-if是对DOM进行移除 解释下什么事$rootScope 以及和 $scope 的区别？scope是angularJS中作用域（其实就是存储数据的地方），很类似javascript的原型链。搜索的时候，优先找自己的scope，如果没有找到就沿着作用域链向上搜索，直至到达根作用域rootScope。 $rootScope是由angularJS加载模块的时候自动创建的，每个模块只会有1个rootScope。rootScope创建好会以拂去的形式加入到$injector中。也就是说通过$injector.get(‘$rootScope’);能够获取到某个模块的根作用域。更准确的来说，$rootScope是由angularJS的核心模块ng创建的。 scope是html和单个controller之间的桥梁，数据绑定就靠它了。rootScope是各个controller中scope的桥梁。用rootScope定义的值，可以在各个controller中使用。 Angular Directive中restrict 中分别可以怎样设置？restrict中可以分别设置：A 匹配属性E 匹配标签C 匹配ClassM 匹配注释AECM 混合匹配 ng-click中写的表达式，能使用JS原生对象上的方法吗？为什么？如果不能该如何实现？不能使用，首先它们两个的作用域是不同，ng-click的作用域是在Angular特有的控制器内的，angular的所有的方法和属性都在控制器中的$scope中,而原生的作用域是全局的。 如何实现：我们可以在ng-click表达式中调用$scope存在的方法名，然后再改方法名中可以调用JS原生对象的方法。 举例说明： &lt;div app=&quot;myApp&quot; controller=&quot;myCtrl&quot;&gt; &lt;p ng-click=&quot;handler()&quot;&gt;找你零钱：{{ money }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, function ($scope) { $scope.money = 3.33; $scope.handler = function () { // 这里使用JS原生的parseInt()方法 return parseInt($scope.money); } }); &lt;/script&gt; angular中的$http是什么，有什么特点？$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。（类似jquery的$.ajax的对象）特点：可以在响应返回时用then方法来处理回调。如果使用then方法，会得到一个特殊的参数，它代表了相应对象的成功或失败信息，还可以接受两个可选的函数作为参数。或者可以使用success和error回调代替。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react]]></title>
      <url>%2F2017%2F04%2F13%2Freact_native%2Freact%2F</url>
      <content type="text"><![CDATA[hello world, i from react.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angular]]></title>
      <url>%2F2017%2F04%2F13%2Fangularjs%2Fangular%2F</url>
      <content type="text"><![CDATA[hello world , I was angular.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装Git]]></title>
      <url>%2F2016%2F08%2F16%2Fgithub%2Fat03%2F</url>
      <content type="text"><![CDATA[安装配置Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。下载地址：http://git-scm.com/downloads Windows 平台安装在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：http://msysgit.github.io/ 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Mac 平台安装在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：http://sourceforge.net/projects/git-osx-installer/ 安装界面如下所示： 配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是Git？]]></title>
      <url>%2F2016%2F08%2F16%2Fgithub%2Fat02%2F</url>
      <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[教程：注册github账号]]></title>
      <url>%2F2016%2F08%2F14%2Fgithub%2Fat01%2F</url>
      <content type="text"><![CDATA[github是世纪上最大的开源代码托管网站。因为是国外网站，很多人在注册的时候因为不熟悉英语而犯了难。 打开浏览器，输入https://github.com/,或 点击这里 进入官网 百度搜索github进入官网。如果你已经有账号密码，那么点击右上角的sign in直接登录，如果没有那么我来教您如何注册。 填写昵称（用户名）、注册邮箱和密码。但是有一些注意事项。 昵称一栏，每次在你输入昵称之后，都会检查是否已经被注册。如果被注册了，那么会提示Username is already taken。此时请换另一个昵称进行注册。 还要注意。昵称中只能出现字母、数字、短横线（-）。并且短横线不能打头。所以中文是不合法昵称。而_abcd也不合法，因为短横线在开头。 邮箱要填写合法邮箱，并且是未在github注册过的邮箱。否则会弹出错误提示。 在三个输入框中的信息都合法之后，它们右边会出现绿色小箭头。此时点击最下方的绿色大按钮来开始注册。（总体来说github的注册方式比国内网站的注册方式简单很多的，每个确认密码，也没有验证码和其他杂七杂八的东西） 这时会弹出一个界面，让你选择你的私人计划（personal plan），即选择免费用户还是付费用户。付费用户可以拥有私人代码仓库（repos），即别人不能查看你的代码。免费用户的仓库都是公开的，任何人都能查看。这里我们选择免费用户就可以了。默认的FREE后面Chosen按钮已经是选中状态了。如果你想成为付费用户，那么点击上面的Chosen按钮。第二个红箭头前面的单选框是可选的，打不打勾都可以，最后我们点击右下角的绿色按钮Finish sign up来完成注册]]></content>
    </entry>

    
  
  
</search>
