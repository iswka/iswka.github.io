<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[一些常见的面试题]]></title>
      <url>%2F2017%2F04%2F15%2Fcss%2Finterview01%2F</url>
      <content type="text"><![CDATA[浏览器页面有哪三层构成，分别是什么，作用是什么？构成： 结构层、表示层、行为层 分别是： HTML CSS JavaScript 作用： HTML实现页面结构；CSS完成页面的表现与风格；JavaScript实现一些客户端的功能与业务。 什么是语义化的HTML？ 直观的认识标签，对于搜索引擎的抓取有好处，用正确的标签做正确的事情。 html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜素引擎的爬虫依赖标签来确定上下文和各个关键字的权重，利于SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 CSS居中（包括水平居中和垂直居中）水平居中设置 内联元素居中 行内元素 设置 text-align:center; Flex布局 设置display:flex; justify-content: center;(灵活运用，支持Chrome，Firefox，IE9+) 设置dispaly:table-cell 再设置 vertical-align:middle; 块级元素居中 定宽块状元素 设置左右margin:auto; 不定宽块状元素 在元素外加入table标签（完整的，包括table,tbody,tr,td),该元素写在td内，然后设置margin: auto; 给该元素设置display: inline; 父元素设置position:relative和left: 50%, 子元素设置position:relative和left: 50% 垂直居中设置 使用position:absolute(fixed),设置left,top,marign-left,margin-top的属性； 使用position:fixed(absolute)属性， margin:auto这个不要忘记； 使用display: table-cell属性使内容垂直居中； 使用css3的新属性transfrom:translate(x,y)属性； 使用:before元素 CSS3有哪些新特性？CSS3实现圆角（border-radius: 8px)，阴影（box-shadow: 10px)，对文字加特效（text-shadow），线性渐变（gradient），变换（transform）【rotate/旋转, scale/缩放, translate/位移, skew/倾斜】 增加了更多的CSS选择器、多背景、 rgba。 事件委托是什么？让利用时间冒泡的原理，让自己的所触发的时间，让他的父元素代替执行！ 添加、删除、替换、插入到某个接点的方法 obj.appendChild() obj.removeChild() obj.replaceChild() obj.insertBefore() 什么叫优雅降级和渐进增强？ 优雅降级 Web站点在所有新式浏览器中都能正常工作，如果用户使用额是老式浏览器，则代码会检查以确认它们 是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些 无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。 渐进增强 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面增加无害于基础 浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。 JavaScript原型，原型链？有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的proto属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链 如何阻止事件冒泡和默认事件 阻止冒泡 现代浏览器：e.stopPropagation(); 低版本浏览器： e.cancelBubble = true; 阻止默认事件 现代浏览器： e.preventDefault(); 低版本浏览器：return false; IOS苹果和微信中音频和视频实现自动播放的方法// 一般情况下，这样就可以自动播放了，但是一些奇葩IPone机不可以 document.getElementById(&apos;audio&apos;).play(); // 必须在微信Weixin JSAPI的WeixinJSBridgeReady才能生效 document.addEventListener(&apos;WeixinJSBridgeReady&apos;,funciton () { document.getElementById(&apos;audio&apos;).play(); document.getElementById(&apos;video&apos;).play(); }, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在GitHub上绑定域名]]></title>
      <url>%2F2017%2F04%2F15%2Fgithub%2Fbinddomain%2F</url>
      <content type="text"><![CDATA[如果我们买了一个自己的域名，那么我们只需要简单的做几步就可以把我们github上的主页和我们的域名进行绑定了。 在主项目里新建一个文件CNAME，没有后缀哦，然后在里面写上自己需要绑定的域名 格式为：【自定义的名称.详细域名】 示例为： iswka.ishelloworld.cn 不要www前缀，iswka这是一个二级域名 然后去域名提供商，比如阿里云上去设置 找到域名，然后点击 “解析” 记录类型我们选择CNAME的方式，注意不要选择A记录(A记录指向的是IP) 。 然后修改主机记录 格式为：你的github名称 比如我的是 iswka 备注：这是我们自定义的二级域名 最后修改记录值 修改格式为：你的github名称.github.io 比如我的是：iswka.github.io 点击保存要不了10分钟就解析成功了,一般会立即生效。 访问域名 通过 “你的github名称.你的主域名” 比如我的 iswka.ishelloworld.cn 就可以访问我们自己的主页了。 备注：如果你访问的是github的地址(比如：http://iswka.github.io/)，那么也会跳转到你刚刚绑定的域名地址。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些面试题01]]></title>
      <url>%2F2017%2F04%2F15%2Fjavascript%2Finterview01%2F</url>
      <content type="text"><![CDATA[##### 1. var a = []; a[0] = 0; a[1] = 1; a[4] = 4; 请问a.length的值是多少？a[3]的输出结果是什么？ 答： 5 undefined ##### 2. function Foo() { var i = 0; return function () { console.log(i++); } } var f1 = Foo(); f2 = Foo(); f1(); f1(); f2(); console.log(i); 请问打印输出的结果是多少？ 答： 0 // f1 = Foo()相当于f1赋值为函数Foo()的返回值f1 = function() { console.log(i ++); } 1 // 因为f1在上一次的基础上又执行了一次函数，i ++ ,是在同一块内存中。 0 报错 // i 为 Foo内部的变量，全局不可访问，全局中没有i变量所以会报错。 请解释GET/POST的区别GET请求：请求的数据会附加在URL之后，以？分割URL和传输数据，多个参数用&amp;链接。 URL的拜年吗格式采用的ASCLL编码，而不是Unicode，即事说所有的非ASCLL字符都要编码 之后再传输。 POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是 实际的传输数据。 因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。 传输数据的大小 在HTTP规范中，没有URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。 对于POST，由于不是URL传值，理论上是不会受到限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。 安全性 GET是Form的默认方法，安全性相对比较低。 请你描述一下cookies, sessionStorage 和 localStorage 的区别？sessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器之间不必要地来回传递。 sessionStorage、 localStorage、 cookie 都是浏览器端存储的数据，其中 sessionStorage的概念很特别，引入了一个”浏览器窗口”的概念。sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时”独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的。 cookies会发送到服务器端。其余两个不会。 Microsoft指出 Internet Explorer 8 增加 cookie 限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。 Firefox每个域名cookie限制为50个。Opera每个明月cookie限制为30个。Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。Opera允许cookie多达4096个字节，包括名（name）、值（value）和等号。Internet Explorer允许 cookie多达4095个字节，包括：名（name）、值（value）和等号。 Cookie 每个域名存储量比较小（各浏览器不同，大致4K) 所有域名的存储量有限制（各浏览器不同，大致4K) 有个数限制（各浏览器不同) 会随请求发送到服务器。 LocalStorage 永久存储 单个域名存储量比较大（推荐5MB，各浏览器不同） 总体数量无限制 SessionStorage 只在Session内有效 存储量更大（推荐没有限制，但实际上各浏览器也不同） image 和 canvas 在处理图片的时候有什么区别？image 是通过对象的形式描述图片的 canvas 通过专门的API将图片绘制在画布上 响应式布局的时候，轮播图使用两张不同的图片去适配大屏幕和超小屏幕，还是一张图片进行压缩适配不同终端，说明原因？最好使用两张不同大小的图片去适配大屏幕和超小屏幕，这样可以针对不同设备的屏幕大小，来加载相应的图片，减少超小屏幕设备的网络流量消耗，加快相应速度，同时防止图片在大屏幕下分辨率不够导致失真的问题。 例举3种强制类型转换和2种隐式类型转换强制（ parseInt parseFloat Number) 隐式（ == ===) ajax请求时，如何解析JSON数据 JSOn.parse eval() new Function() CSS 清除浮动的几种方法 使用带clear属性的空元素 使用CSS的overflow属性 使用CSS的:after伪元素 使用邻接元素处理 封装一个方法实现获取样式的兼容写法function getStyle(ele, style) { if (window.getComputedStyle) { return getComputedStyle(ele, null)[style]; } else { return obj.currentStyle(style); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组件之ActivityIndicator、WebView]]></title>
      <url>%2F2017%2F04%2F15%2Freact_native%2Fat02%2F</url>
      <content type="text"><![CDATA[ActivityIndicator 组件作用：显示一个loading加载提示的符号。 属性： animating bool 是否要显示指示器。默认为true color string 滚轮的前景颜色（默认为灰色） size enum(‘small’, ‘large’) 指示器的大小。small的高度为20，large的高度为36. 例子import React, { Component } from &apos;react&apos;; import { ActivityIndicator } from &apos;react-native&apos;; export default class activityIndicator extends Component { render() { return ( &lt;ActivityIndicator style={{ marginTop: 100 }} color=&quot;green&quot; size=&quot;large&quot; /&gt; ); } } WebView 组件作用创建一个原生的WebView，可以用于访问一个网页。 用法 webView,网络视图可以在这个内部引入别的网页，使用source进入引入 例子import React, { Component } from &apos;react&apos;; import { WebView } from &apos;react-native&apos;; // 引入京东手机版 export default class WebViewCom extends React.Component { render() { return ( &lt;WebView source={{ url: 'http://m.jd.com' }} /&gt; ); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[练习题]]></title>
      <url>%2F2017%2F04%2F14%2Freact_native%2Fexercise05%2F</url>
      <content type="text"><![CDATA[实现一个Navigator，要求包括跳转到新页面的新页面的回退，并且在页面切换时有数据传输 import React, { Component } from &apos;react&apos;; import { Navigator, Text, TextInput, View, TouchableOpacity, StyleSheet } from &apos;react-native&apos;; export default class Nav extends Component { render() { // 初始化路由 var rootRoute = { component: FirstPage, nextPass: {} }; return ( &lt;Navigator //{/* 设置默认的路由 */} initialRoute={ rootRoute } //{/* 切换页面方式 */} configureScene={ (route) =&gt; Navigator.SceneConfigs.PushFromRight } //{/* 确定要渲染的场景 */} renderScene={ (route, navigator) =&gt; { // 找到要渲染的页面 var Component = route.component; // 返回组件， 把组件的route 和 navigator // 把属性也传递过去 return &lt;Component { ...route.nextPass } route={ route } navigator={ navigator }/&gt; }} /&gt; ); } } class SecondPage extends Component { changePage() { this.props.navigator.pop(); } render() { return ( &lt;View style={[ styles.second, styles.container ]}&gt; &lt;Text&gt;接收到的数据：{ this.props.text }&lt;/Text&gt; &lt;TouchableOpacity style={ styles.btn } onPress={ this.changePage.bind(this) }&gt; &lt;Text style={ styles.txt }&gt;点击返回上一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } class FirstPage extends Component { constructor(props) { super(props); this.state = { text: &apos;&apos; } } saveText(text) { this.setState({ text: text }); } changePage() { var nextRoute = { component: SecondPage, nextPass: { text: this.state.text } }; this.props.navigator.push(nextRoute); } render() { return ( &lt;View style={[ styles.first, styles.container ]}&gt; &lt;TextInput placeholder={ &apos;请输入&apos; } style={ styles.input } onChangeText={ this.saveText.bind(this) }&gt;&lt;/TextInput&gt; &lt;TouchableOpacity style={ styles.btn } onPress={ this.changePage.bind(this) }&gt; &lt;Text style={ styles.txt }&gt;点击进入下一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, }, first: { backgroundColor: &apos;cyan&apos;, }, second: { backgroundColor: &apos;pink&apos;, }, input: { height: 25, borderWidth: 1, }, btn: { width: 150, height: 20, backgroundColor: &apos;yellow&apos;, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, borderRadius: 5, }, txt: { } }); 实现一个TabBar，要求至少包括四项，要求有四项标签 import React, { Component } from &apos;react&apos;; import { TabBarIOS, Text, View, StyleSheet } from &apos;react-native&apos;; // 引入三个图片 import movieIcon from &apos;./../public/images/movie.png&apos;; import homeIcon from &apos;./../public/images/home.png&apos;; import picIcon from &apos;./../public/images/pic.png&apos;; import musicIcon from &apos;./../public/images/music.png&apos;; export default class TabBar2 extends Component { constructor(props) { super(props); // 初始状态 this.state = { isShow: &apos;首页&apos; }; } press(tabName) { this.setState({ isShow: tabName }); } render() { return ( &lt;TabBarIOS&gt; &lt;TabBarIOS.Item title=&quot;首页&quot; icon={ homeIcon } onPress={ this.press.bind(this, &apos;首页&apos;) } selected={ this.state.isShow === &apos;首页&apos; } &gt; &lt;FirstPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;电影&quot; icon={ movieIcon } onPress={ this.press.bind(this, &apos;电影&apos;) } selected={ this.state.isShow === &apos;电影&apos; } &gt; &lt;SecondPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;相册&quot; icon={ picIcon } onPress={ this.press.bind(this, &apos;相册&apos;) } selected={ this.state.isShow === &apos;相册&apos; } &gt; &lt;ThreePage/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;音乐&quot; icon={ musicIcon } onPress={ this.press.bind(this, &apos;音乐&apos;) } selected={ this.state.isShow === &apos;音乐&apos; } &gt; &lt;FourPage/&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); } } class FourPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.four ]}&gt; &lt;Text&gt;这是第四个页面&lt;/Text&gt; &lt;/View&gt; ); } } class ThreePage extends Component { render() { return ( &lt;View style={[ styles.container, styles.three ]}&gt; &lt;Text&gt;这是第三个页面&lt;/Text&gt; &lt;/View&gt; ); } } class SecondPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.second ]}&gt; &lt;Text&gt;这是第二个页面&lt;/Text&gt; &lt;/View&gt; ); } } class FirstPage extends Component { render() { return ( &lt;View style={[ styles.container, styles.first ]}&gt; &lt;Text&gt;这是第一个页面&lt;/Text&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;, }, first: { backgroundColor: &apos;yellow&apos;, }, second: { backgroundColor: &apos;red&apos;, }, three: { backgroundColor: &apos;blue&apos; }, four: { backgroundColor: &apos;pink&apos; } }); 实现一个电影列表，要求通过网络请求读取数据，通过ListView实现，并且在数据加载时有loading组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown-快速入门]]></title>
      <url>%2F2017%2F04%2F14%2Fmarkdown%2Fbasic%2F</url>
      <content type="text"><![CDATA[前言markdown是一门很容易上手的轻量级语言这里提供一个Dingus,它是一个网页应用程序，可以将MarkDown文档转换成XHTML文档。 段落一般由回车换行即可，MarkDown将该行为标识为一个段落【注意：这样的段落没有缩进】 标题MarkDown支持两种标题语法，Setext和tx形式。Setext用底限形式，利用=（最高阶标题）和-（第二阶标题）；Atx是在行首插入1到6个#，对应HTML标题H1…H6。 区块代码区块代码使用Email形式的’&gt;’角括号 修辞和强调使用星号 (*) 和 (_) 底线标记需要强调的区段 _修辞和强调的区段_ 等价于 &lt;em&gt;修辞和强调的区段&lt;/em&gt; *修辞和强调的区段* 等价于 &lt;em&gt;修辞和强调的区段&lt;/em&gt; __修辞和强调的区段__ 等价于 &lt;strong&gt;修辞和强调的区段&lt;/strong&gt; **修辞和强调的区段** 等价于 &lt;strong&gt;修辞和强调的区段&lt;/strong&gt; 列表无序列表： 使用星号（*）加号（+）减号（-）来作为列表的项目标记 有序列表： 一般是一个数字接着一个英文句点（.）作为项目标记 链接支持两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号把文字转成链接。 行内形式是直接在后面用括号直接接上链接 This is an [example link](http://example.com/). 你也可以选择性的加上title属性 This is an [example link](http://example.com/ &quot;With a title&quot;). 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容。 I get 10 times more traffic from [Google][1] than from [baidu][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://baidu.com/ &quot;Baidu&quot; [3]: http://search.msn.com/ &quot;MSN&quot; 图片图片的语法和链接一样，同样有行内和参考两种形式， 行内形式 ![alt text](/path/icon.png &quot;Title&quot;) 参考形式 ![alt text][id] [id]: /path/icon.png &quot;Title&quot; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp; 、 &lt; 和 &gt; 都会被转换成HTML实体，这项特性让你可以很容易的在代码区段内插入HTML代码 如果要建立一个已经格式化好的代码区块，只要每行缩进4个空格或者一个Tab就可以了。而 &amp; 、&lt; 和 &gt; 也一样会转成HTML实体]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组件之navigator、ListView]]></title>
      <url>%2F2017%2F04%2F14%2Freact_native%2Fat01%2F</url>
      <content type="text"><![CDATA[Navigator使用导航器可以让你在应用的不同场景（页面）进行切换。导航器通过不同路由来分辨不同的场景。利用renderScene方法，导航栏可以指定的路由来渲染场景 可以通过configureScene属性获取指定路由对象的配置信息，从而改变场景的动画或者手势。查看navigator.SceneConfigs来获取默认的动画和更多的场景配置选项。 注意：这个组件本文说明简单，但使用上有一定难度。 在使用该组件时，一般需要以下几步： 属性： configScene (function) 可选的函数，用来配置场景动画和手势。会带有两个参数调用，一个是当前路由，一个是当前的路由栈， 然后它返回一个场景配置对象。 initialRoute (object) 定义启动加载的路由，路由是导航栏用来识别渲染场景的一个对象，initialRoute必须是initialRouteStack 中的一个路由。initialRoute默认是initialRouteStack中最后一项。 initialRouteStack (object) 提供一个路由集合用来初始化。如果没有设置初始路由的话必须设置初始路由。如果没有提供该属性，它将默认被设置 成一个只含有initialRoute的数组。 navigationBar (node) 可选参数，提供一个在场景切换的时候保持的导航条。 navigator (object) 可选参数，提供从父容器获得的导航器对象。 onDidFocus (function) 每当导航条切换完成或者初始化之后，调用此函数，参数为新场景的路由。 onWillFocus (function) 会在导航条切换之前调用，参数为目标路由。 renderScene (function) 必要参数。用来渲染指定参数路由的场景。调用的参数是路由和导航器。 senceStyle (View#style) 将会应用在每个场景容器上的样式。 ListView核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表。最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组，再使用数据源实例化一个ListView组件，并且定义它的回调函数_renderRow。该函数会接受数组中每个数据作为参数。返回一个可渲染的组件。 ListView还支持一些高级特性，这个本人还没有尝试，以后详解哈。 属性： renderRow (function) 从数据源中接收一条数据，以及和它所在的section的ID。返回一个可渲染的组件来为这行数据进行渲染。默认情况下 参数中的数据就是放进数据源的数据本身，不过也可以提供一些转换器。 如果某一行正在被高亮（通过调用highlightRow函数），ListView会得到相应的通知。当一行被高亮时，其两侧的分割线 会被隐藏。行的高亮状态可以通过调用highlistRow(null)来重置。 renderHeader (function) 渲染页头。 renderSeparator (function) 如果提供了此属性，一个可渲染的组件会被渲染在每一行的下面。除了小节标题的前面的最后一行。在其上方的小节ID和行ID，以及 邻近的行是否被高亮会作为参数被传递进来。 例子： /** * 猫眼电影列表页 * 数据 * http://m.maoyan.com/movie/list.json?type=hot&amp;offset=0&amp;limit=1000 */ import React, { Component } from &apos;react&apos;; import { ListView, ActivityIndicator, View, Text, Image, StyleSheet } from &apos;react-native&apos;; // 引入猫眼数据 import movieData from &apos;./../public/json/maoyan.json&apos;; export default class MoveList extends Component { constructor(props) { super(props); var ds = new ListView.DataSource({ rowHasChanged: (oldData, newData) =&gt; oldData !== newData }); this.state = { dataSource: ds }; } _renderHeader() { return ( &lt;View style={ styles.header }&gt; &lt;Text style={ styles.header_txt }&gt;猫眼热门电影&lt;/Text&gt; &lt;/View&gt; ); } _renderRow(movie) { return ( &lt;View style={ styles.row }&gt; &lt;View style={ styles.left }&gt; &lt;Image source={{ uri: movie.img }} style={ styles.img }&gt;&lt;/Image&gt; &lt;/View&gt; &lt;View style={ styles.right }&gt; &lt;Text style={[ styles.nm, styles.txt_right ]}&gt;{ movie.nm }&lt;/Text&gt; &lt;Text style={[ styles.dir, styles.txt_right ]}&gt;导演：{ movie.dir }&lt;/Text&gt; &lt;Text style={[ styles.rt, styles.txt_right ]}&gt;上映时间：{ movie.rt }&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); } _renderSeparator() { return ( &lt;View style={ styles.separator }&gt;&lt;/View&gt; ); } componentDidMount() { // 把已经解析好的数据使用到我们的页面 var ds = new ListView.DataSource({ rowHasChanged: (oldData,newData) =&gt; oldData !== newData }); this.setState({ dataSource: ds.cloneWithRows(movieData.data.movies) }); } render() { return ( &lt;ListView style={ styles.container } dataSource={ this.state.dataSource } renderHeader={ this._renderHeader } renderRow={ this._renderRow } renderSeparator={ this._renderSeparator } &gt; &lt;/ListView&gt; ); } } const styles = StyleSheet.create({ container: { marginTop: 25, marginLeft: 10, marginRight: 10, }, header: { height: 50, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;pink&apos;, borderRadius: 6, }, header_txt: { fontSize: 30, color: &apos;darkgrey&apos; }, row: { height: 160, flexDirection: &apos;row&apos;, marginTop: 10, }, left: { width: 110, }, right: { justifyContent: &apos;center&apos;, }, separator: { height: 2, backgroundColor: &apos;#ccc&apos; }, img: { width: 100, height: 150, }, txt_right: { marginBottom: 10 }, nm: { fontSize: 26, fontWeight: &apos;bold&apos;, }, dir: { fontSize: 16, color: &apos;orange&apos; }, rt: { color: &apos;grey&apos; } }); 提示 有关猫眼数据，可点击链接接收JSON数据：http://m.maoyan.com/movie/list.json?type=hot&amp;offset=0&amp;limit=100【limit=?，这里输入的是你要获取电影信息的条目数，最多只能获取100条】 效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的Angular疑问解答]]></title>
      <url>%2F2017%2F04%2F13%2Fangularjs%2Fexercise01%2F</url>
      <content type="text"><![CDATA[列举你所知道的angular指令（不少于10个） ng-bind ng-model ng-app ng-controller ng-init ng-repeat ng-hide ng-show ng-if ng-keydown 请写出一个双向数据绑定的例子&lt;div ng-app=&quot;myApp&quot; ng-init=&quot;name=&apos;John&apos;&quot;&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;你输入的姓名：{{ name }}&lt;/p&gt; &lt;/div&gt; 请列举写出angular的事件绑定，要求事件触发时会有相应的方法执行&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;button ng-click=&quot;handler()&quot;&gt;&lt;/button&gt; &lt;p ng-show=&quot;isShow&quot;&gt;隐藏/显示&lt;/p&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, function ($scope) { $scope.isShow = true; $scope.handler = function () { $scope.isShow = !$scope.isShow; } }); &lt;/script&gt; &lt;/body&gt; 请举例写出angular自定义指令的方法app.directive(&apos;helloWorld&apos;, function () { return ( template: &apos;&lt;h1&gt;自定义指令&lt;/h1&gt;&apos; ); }); 请举例写出angular发请求的方法（如，发请求到http://localhost:8080/req),并写出返回的数据怎么得到$http({ method: &apos;GET&apos;. url: &apos;http://localhost:8080/req&apos;, }).then(function (res) { // 成功的回调 console.log(res.data); }, function (err) { // 失败的回调 console.log(err); }); ng-show/ng-hide 与 ng-if 的区别？ng-show/ng-hide: 显示或者隐藏HTML元素ng-if: 如果条件为false移除HTML元素，如果条件为true，会添加移除元素，并显示。两者之间最大的区别就是ng-hide是隐藏而ng-if是对DOM进行移除 解释下什么事$rootScope 以及和 $scope 的区别？scope是angularJS中作用域（其实就是存储数据的地方），很类似javascript的原型链。搜索的时候，优先找自己的scope，如果没有找到就沿着作用域链向上搜索，直至到达根作用域rootScope。 $rootScope是由angularJS加载模块的时候自动创建的，每个模块只会有1个rootScope。rootScope创建好会以拂去的形式加入到$injector中。也就是说通过$injector.get(‘$rootScope’);能够获取到某个模块的根作用域。更准确的来说，$rootScope是由angularJS的核心模块ng创建的。 scope是html和单个controller之间的桥梁，数据绑定就靠它了。rootScope是各个controller中scope的桥梁。用rootScope定义的值，可以在各个controller中使用。 Angular Directive中restrict 中分别可以怎样设置？restrict中可以分别设置：A 匹配属性E 匹配标签C 匹配ClassM 匹配注释AECM 混合匹配 ng-click中写的表达式，能使用JS原生对象上的方法吗？为什么？如果不能该如何实现？不能使用，首先它们两个的作用域是不同，ng-click的作用域是在Angular特有的控制器内的，angular的所有的方法和属性都在控制器中的$scope中,而原生的作用域是全局的。 如何实现：我们可以在ng-click表达式中调用$scope存在的方法名，然后再改方法名中可以调用JS原生对象的方法。 举例说明： &lt;div app=&quot;myApp&quot; controller=&quot;myCtrl&quot;&gt; &lt;p ng-click=&quot;handler()&quot;&gt;找你零钱：{{ money }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;, []); app.controller(&apos;myCtrl&apos;, function ($scope) { $scope.money = 3.33; $scope.handler = function () { // 这里使用JS原生的parseInt()方法 return parseInt($scope.money); } }); &lt;/script&gt; angular中的$http是什么，有什么特点？$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。（类似jquery的$.ajax的对象）特点：可以在响应返回时用then方法来处理回调。如果使用then方法，会得到一个特殊的参数，它代表了相应对象的成功或失败信息，还可以接受两个可选的函数作为参数。或者可以使用success和error回调代替。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react]]></title>
      <url>%2F2017%2F04%2F13%2Freact_native%2Freact%2F</url>
      <content type="text"><![CDATA[hello world, i from react.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angular]]></title>
      <url>%2F2017%2F04%2F13%2Fangularjs%2Fangular%2F</url>
      <content type="text"><![CDATA[hello world , I was angular.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装Git]]></title>
      <url>%2F2016%2F08%2F16%2Fgithub%2Fat03%2F</url>
      <content type="text"><![CDATA[安装配置Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。下载地址：http://git-scm.com/downloads Windows 平台安装在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：安装包下载地址：http://msysgit.github.io/ 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 Mac 平台安装在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：http://sourceforge.net/projects/git-osx-installer/ 安装界面如下所示： 配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是Git？]]></title>
      <url>%2F2016%2F08%2F16%2Fgithub%2Fat02%2F</url>
      <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[教程：注册github账号]]></title>
      <url>%2F2016%2F08%2F14%2Fgithub%2Fat01%2F</url>
      <content type="text"><![CDATA[github是世纪上最大的开源代码托管网站。因为是国外网站，很多人在注册的时候因为不熟悉英语而犯了难。 打开浏览器，输入https://github.com/,或 点击这里 进入官网 百度搜索github进入官网。如果你已经有账号密码，那么点击右上角的sign in直接登录，如果没有那么我来教您如何注册。 填写昵称（用户名）、注册邮箱和密码。但是有一些注意事项。 昵称一栏，每次在你输入昵称之后，都会检查是否已经被注册。如果被注册了，那么会提示Username is already taken。此时请换另一个昵称进行注册。 还要注意。昵称中只能出现字母、数字、短横线（-）。并且短横线不能打头。所以中文是不合法昵称。而_abcd也不合法，因为短横线在开头。 邮箱要填写合法邮箱，并且是未在github注册过的邮箱。否则会弹出错误提示。 在三个输入框中的信息都合法之后，它们右边会出现绿色小箭头。此时点击最下方的绿色大按钮来开始注册。（总体来说github的注册方式比国内网站的注册方式简单很多的，每个确认密码，也没有验证码和其他杂七杂八的东西） 这时会弹出一个界面，让你选择你的私人计划（personal plan），即选择免费用户还是付费用户。付费用户可以拥有私人代码仓库（repos），即别人不能查看你的代码。免费用户的仓库都是公开的，任何人都能查看。这里我们选择免费用户就可以了。默认的FREE后面Chosen按钮已经是选中状态了。如果你想成为付费用户，那么点击上面的Chosen按钮。第二个红箭头前面的单选框是可选的，打不打勾都可以，最后我们点击右下角的绿色按钮Finish sign up来完成注册]]></content>
    </entry>

    
  
  
</search>
